import SwiftUI
import Foundation
import AVFoundation

// MARK: - Sound Manager
class SoundManager {
    static let shared = SoundManager()
    var audioPlayer: AVAudioPlayer?

    func playThemeSong() {
        if let bundle = Bundle.main.path(forResource: "theme", ofType: "mp3") {
            let backgroundMusic = NSURL(fileURLWithPath: bundle)
            do {
                audioPlayer = try AVAudioPlayer(contentsOf: backgroundMusic as URL)
                guard let audioPlayer = audioPlayer else { return }
                audioPlayer.numberOfLoops = -1 // Loop indefinitely
                audioPlayer.prepareToPlay()
                audioPlayer.play()
            } catch {
                print(error)
            }
        }
    }
}


// MARK: - Intro View
struct IntroView: View {
    @Binding var isActive: Bool
    @State private var scale = 0.7
    @State private var opacity = 0.5

    var body: some View {
        ZStack {
            Color.black.edgesIgnoringSafeArea(.all)
            Image("intro_display")
                .resizable()
                .scaledToFit()
                .scaleEffect(scale)
                .opacity(opacity)
                .onAppear {
                    withAnimation(.easeInOut(duration: 1.5)) {
                        self.scale = 1.0
                        self.opacity = 1.0
                    }
                    
                    // Delay for the logo to be visible
                    DispatchQueue.main.asyncAfter(deadline: .now() + 2.5) {
                        withAnimation(.easeInOut(duration: 1.0)) {
                            self.opacity = 0.0
                        }
                    }
                    
                    // Transition to the main content
                    DispatchQueue.main.asyncAfter(deadline: .now() + 3.5) {
                        self.isActive = false
                    }
                }
        }
    }
}


// MARK: - Time-Based Reward Manager
class TimeBasedRewardManager: ObservableObject {
    private var timer: Timer?
    
    @Published var showReward = false
    @Published var rewardAmount = 0
    
    var gameStateManager: GameStateManager?

    func startTimer() {
        // Invalidate existing timer if any to prevent duplicates
        timer?.invalidate()
        
        // Start a new timer for 15 minutes (900 seconds)
        // For testing, you might want to set this to a shorter interval, e.g., 15.0
        timer = Timer.scheduledTimer(withTimeInterval: 900.0, repeats: true) { [weak self] _ in
            self?.grantReward()
        }
    }

    func grantReward() {
        guard let gameStateManager = gameStateManager else { return }

        // The reward scales with the highest level the player has completed
        let highestLevelCompleted = (gameStateManager.levels.filter { $0.starRating > 0 }.map { $0.id }.max() ?? 0)
        
        let baseReward = 100
        let scalingFactor = 20
        let maxPossibleRewardForLevel = baseReward + (highestLevelCompleted * scalingFactor)
        
        // The maximum reward is capped at 3000
        let actualMaxReward = min(3000, maxPossibleRewardForLevel)
        
        // Ensure the minimum reward is not greater than the maximum
        guard actualMaxReward >= baseReward else { return }
        
        let amount = Int.random(in: baseReward...actualMaxReward)
        
        DispatchQueue.main.async {
            self.rewardAmount = amount
            gameStateManager.addPaperMoney(amount: self.rewardAmount)
            self.showReward = true
            
            // Hide the reward pop-up after a few seconds
            DispatchQueue.main.asyncAfter(deadline: .now() + 3.0) {
                self.showReward = false
            }
        }
    }
    
    func stopTimer() {
        timer?.invalidate()
        timer = nil
    }
}


// MARK: - Root View (The Router)
struct ContentView: View {
    @State private var showIntro = true

    var body: some View {
        ZStack {
            if showIntro {
                IntroView(isActive: $showIntro)
            } else {
                GameRouterView()
            }
        }
        .onAppear {
            SoundManager.shared.playThemeSong()
        }
    }
}

struct GameRouterView: View {
    @StateObject private var gameStateManager = GameStateManager()
    @StateObject private var rewardManager = TimeBasedRewardManager()

    var body: some View {
        ZStack {
            // This switch statement acts as the navigation router
            switch gameStateManager.currentState {
            case .mainMenu:
                MainMenuView(gameStateManager: gameStateManager)
            case .worldSelect:
                WorldSelectView(gameStateManager: gameStateManager) // New Case
            case .levelSelect:
                LevelSelectView(gameStateManager: gameStateManager)
            case .store:
                StoreView(gameStateManager: gameStateManager)
            case .profile:
                ProfileView(gameStateManager: gameStateManager)
            case .army:
                ArmyView(gameStateManager: gameStateManager)
            case .packOpening(let crate):
                PackOpeningView(gameStateManager: gameStateManager, crate: crate)
            case .battle(let level):
                BattleView(gameStateManager: gameStateManager, level: level)
            case .postLevelVictory(let money, let stars):
                PostLevelVictoryView(gameStateManager: gameStateManager, moneyGained: money, stars: stars)
            }
            
            // Time-based Reward Pop-up
            if rewardManager.showReward {
                TimeRewardView(amount: rewardManager.rewardAmount)
            }
        }
        .onAppear {
            rewardManager.gameStateManager = gameStateManager
            rewardManager.startTimer()
        }
        .onDisappear {
            rewardManager.stopTimer()
        }
        .transition(.opacity.animation(.easeInOut(duration: 0.4)))
    }
}

// MARK: - Custom Font Modifier
struct MinecraftFont: ViewModifier {
    var size: CGFloat
    var color: Color = .white

    func body(content: Content) -> some View {
        content
            .font(.custom("AmericanTypewriter-Bold", size: size))
            .foregroundColor(color)
            .shadow(color: .black, radius: 0, x: 1, y: 1)
            .shadow(color: .black, radius: 0, x: -1, y: -1)
            .shadow(color: .black, radius: 0, x: 1, y: -1)
            .shadow(color: .black, radius: 0, x: -1, y: 1)
    }
}

extension View {
    func minecraftFont(size: CGFloat = 28, color: Color = .white) -> some View {
        self.modifier(MinecraftFont(size: size, color: color))
    }
}

// MARK: - Core Game Models
enum AbilityEffect {
    case damage, heal, defenseUp, attackUp, stun, lifesteal, aoeDamage, taunt, burn, thorns
}

struct Ability {
    let name: String
    let description: String
    let effect: AbilityEffect
    let baseValue: Int
    let levelMultiplier: Int
    let chance: Double // Chance to trigger, e.g., 0.15 for 15%
}

struct CharacterInstance: Identifiable, Equatable {
    let id = UUID()
    let characterId: String
    var level: Int = 1
    var xp: Int = 0
    
    var base: GameCharacter {
        GameDB.allCharacters[characterId] ?? GameCharacter(id: "error", name: "Error", baseAttack: 1, baseHealth: 1, attackGrowth: 0, healthGrowth: 0, sourceCrate: 0, recycleXpValue: 0, ability: GameDB.defaultAbility, criticalChance: 0.0, burnChance: 0.0, thornsDamage: 0.0)
    }
    
    var name: String { base.name }
    var maxXp: Int { 100 * level }
    var attack: Int { base.baseAttack + (level - 1) * base.attackGrowth }
    var health: Int { base.baseHealth + (level - 1) * base.healthGrowth }
    
    var canUpgrade: Bool { xp >= maxXp }
}

struct EnemyInstance: Identifiable {
    let id: String
    let levelId: Int
    var base: GameCharacter { GameDB.allEnemies[id]! }
    
    var name: String { base.name }
    
    var health: Int {
        let scalingFactor = 1.0 + (Double(levelId) * 0.08)
        return Int(Double(base.baseHealth) * scalingFactor)
    }
    var attack: Int {
        let scalingFactor = 1.0 + (Double(levelId) * 0.08)
        return Int(Double(base.baseAttack) * scalingFactor)
    }
}

// MODIFICATION: Added new properties to GameCharacter for the new abilities.
struct GameCharacter: Identifiable {
    let id: String
    var name: String
    var baseAttack: Int
    var baseHealth: Int
    var attackGrowth: Int
    var healthGrowth: Int
    var sourceCrate: Int
    var recycleXpValue: Int
    var ability: Ability
    var criticalChance: Double // Chance for a critical hit (e.g., 0.1 for 10%)
    var burnChance: Double     // Chance to apply burn status (e.g., 0.2 for 20%)
    var thornsDamage: Double   // Percentage of damage reflected back (e.g., 0.15 for 15%)
}

struct PlayerProfile {
    var displayName: String = "Hero"
    var bio: String = "Ready to save Paper World!"
    var profileImageName: String = "default_profile_pic"
    var mainCharacterInstanceId: UUID
    var characterCollection: [CharacterInstance]
    var currentLevelId: Int = 1
    var paperMoney: Int = 500
    var mainCharacter: CharacterInstance? {
        characterCollection.first { $0.id == mainCharacterInstanceId }
    }
}

enum LevelDifficulty: String {
    case easy = "Easy"
    case medium = "Medium"
    case hard = "Hard"
}

struct Level: Identifiable {
    let id: Int
    var starRating: Int = 0
    var enemyIds: [String]
    var isUnlocked: Bool
    var difficulty: LevelDifficulty
    var platformAssetName: String
}

// New World Struct
struct World: Identifiable {
    let id: Int
    let name: String
    let imageName: String
    let unlockLevel: Int
}

struct Crate: Identifiable {
    var id: String { name }
    var name: String
    var imageName: String
    var cost: Int
    var tier: Int
}

struct DamageText: Identifiable {
    let id = UUID()
    let text: String
    let color: Color
    var isPlayerDamage: Bool
}

struct ShootingStar: Identifiable {
    let id = UUID()
    let startPoint: CGPoint
    let endPoint: CGPoint
    let duration: Double
}

// FIXED: The missing BattleResult enum has been added here.
enum BattleResult {
    case victory, defeat
}

// MARK: - Game Database
struct GameDB {
    static let defaultAbility = Ability(name: "Default", description: "A default ability.", effect: .damage, baseValue: 0, levelMultiplier: 0, chance: 0)
    
    // MODIFICATION: Added values for criticalChance, burnChance, and thornsDamage to each character.
    static let allCharacters: [String: GameCharacter] = [
        "character_starter": GameCharacter(id: "character_starter", name: "PiÃ±ata", baseAttack: 11, baseHealth: 75, attackGrowth: 2, healthGrowth: 9, sourceCrate: 1, recycleXpValue: 10, ability: Ability(name: "Candy Rush", description: "Heals for a small amount.", effect: .heal, baseValue: 10, levelMultiplier: 2, chance: 0.2), criticalChance: 0.05, burnChance: 0.0, thornsDamage: 0.0),
        "character1_crate1": GameCharacter(id: "character1_crate1", name: "Patch", baseAttack: 10, baseHealth: 80, attackGrowth: 2, healthGrowth: 10, sourceCrate: 1, recycleXpValue: 20, ability: Ability(name: "Reinforce", description: "Briefly increases defense.", effect: .defenseUp, baseValue: 5, levelMultiplier: 1, chance: 0.25), criticalChance: 0.05, burnChance: 0.0, thornsDamage: 0.0),
        "character2_crate1": GameCharacter(id: "character2_crate1", name: "Scrappy", baseAttack: 12, baseHealth: 70, attackGrowth: 3, healthGrowth: 8, sourceCrate: 1, recycleXpValue: 20, ability: Ability(name: "Furious Swipe", description: "Deals extra damage.", effect: .damage, baseValue: 20, levelMultiplier: 3, chance: 0.15), criticalChance: 0.1, burnChance: 0.0, thornsDamage: 0.0),
        "character3_crate1": GameCharacter(id: "character3_crate1", name: "Rusty", baseAttack: 8, baseHealth: 100, attackGrowth: 1, healthGrowth: 12, sourceCrate: 1, recycleXpValue: 20, ability: Ability(name: "Taunt", description: "Forces the enemy to attack Rusty.", effect: .taunt, baseValue: 0, levelMultiplier: 0, chance: 0.3), criticalChance: 0.05, burnChance: 0.0, thornsDamage: 0.1),
        "character1_crate2": GameCharacter(id: "character1_crate2", name: "Sergeant Stitch", baseAttack: 15, baseHealth: 120, attackGrowth: 4, healthGrowth: 15, sourceCrate: 2, recycleXpValue: 50, ability: Ability(name: "Medic", description: "Heals for a moderate amount.", effect: .heal, baseValue: 30, levelMultiplier: 5, chance: 0.2), criticalChance: 0.05, burnChance: 0.0, thornsDamage: 0.0),
        "character2_crate2": GameCharacter(id: "character2_crate2", name: "Major Mark", baseAttack: 18, baseHealth: 100, attackGrowth: 5, healthGrowth: 12, sourceCrate: 2, recycleXpValue: 50, ability: Ability(name: "Sharpshooter", description: "Deals high damage to a single target.", effect: .damage, baseValue: 40, levelMultiplier: 6, chance: 0.15), criticalChance: 0.15, burnChance: 0.0, thornsDamage: 0.0),
        "character3_crate2": GameCharacter(id: "character3_crate2", name: "Captain Cardboard", baseAttack: 13, baseHealth: 150, attackGrowth: 3, healthGrowth: 18, sourceCrate: 2, recycleXpValue: 50, ability: Ability(name: "Shield Wall", description: "Greatly increases defense for a short time.", effect: .defenseUp, baseValue: 15, levelMultiplier: 3, chance: 0.25), criticalChance: 0.05, burnChance: 0.0, thornsDamage: 0.2),
        "character4_crate2": GameCharacter(id: "character4_crate2", name: "The Enforcer", baseAttack: 20, baseHealth: 90, attackGrowth: 6, healthGrowth: 10, sourceCrate: 2, recycleXpValue: 50, ability: Ability(name: "Stun Grenade", description: "Has a chance to stun the enemy.", effect: .stun, baseValue: 0, levelMultiplier: 0, chance: 0.1), criticalChance: 0.1, burnChance: 0.2, thornsDamage: 0.0),
        "character1_crate3": GameCharacter(id: "character1_crate3", name: "Lord Lamination", baseAttack: 25, baseHealth: 180, attackGrowth: 7, healthGrowth: 25, sourceCrate: 3, recycleXpValue: 150, ability: Ability(name: "Holy Light", description: "Heals for a large amount.", effect: .heal, baseValue: 60, levelMultiplier: 10, chance: 0.2), criticalChance: 0.1, burnChance: 0.0, thornsDamage: 0.0),
        "character2_crate3": GameCharacter(id: "character2_crate3", name: "Sir Foldingham", baseAttack: 30, baseHealth: 150, attackGrowth: 9, healthGrowth: 20, sourceCrate: 3, recycleXpValue: 150, ability: Ability(name: "Blade Dance", description: "Deals massive damage to a single target.", effect: .damage, baseValue: 70, levelMultiplier: 12, chance: 0.15), criticalChance: 0.2, burnChance: 0.0, thornsDamage: 0.0),
        "character3_crate3": GameCharacter(id: "character3_crate3", name: "The Pulp Fiend", baseAttack: 22, baseHealth: 220, attackGrowth: 6, healthGrowth: 30, sourceCrate: 3, recycleXpValue: 150, ability: Ability(name: "Absorb", description: "Drains health from the enemy.", effect: .lifesteal, baseValue: 25, levelMultiplier: 4, chance: 0.2), criticalChance: 0.1, burnChance: 0.0, thornsDamage: 0.3),
        "character4_crate3": GameCharacter(id: "character4_crate3", name: "Origami Overlord", baseAttack: 35, baseHealth: 140, attackGrowth: 10, healthGrowth: 18, sourceCrate: 3, recycleXpValue: 150, ability: Ability(name: "Thousand Cranes", description: "Deals damage to all enemies.", effect: .aoeDamage, baseValue: 30, levelMultiplier: 5, chance: 0.1), criticalChance: 0.15, burnChance: 0.3, thornsDamage: 0.0),
        "character5_crate3": GameCharacter(id: "character5_crate3", name: "King Cardboard", baseAttack: 28, baseHealth: 200, attackGrowth: 8, healthGrowth: 28, sourceCrate: 3, recycleXpValue: 150, ability: Ability(name: "Royal Decree", description: "Increases the attack of all allies.", effect: .attackUp, baseValue: 10, levelMultiplier: 2, chance: 0.25), criticalChance: 0.1, burnChance: 0.0, thornsDamage: 0.25),
        
        // Crate 4 Characters
        "character1_crate4": GameCharacter(id: "character1_crate4", name: "The Incinerator", baseAttack: 40, baseHealth: 200, attackGrowth: 12, healthGrowth: 28, sourceCrate: 4, recycleXpValue: 500, ability: Ability(name: "Inferno", description: "Deals high damage with a high chance to burn.", effect: .burn, baseValue: 50, levelMultiplier: 8, chance: 0.5), criticalChance: 0.15, burnChance: 0.5, thornsDamage: 0.0),
        "character2_crate4": GameCharacter(id: "character2_crate4", name: "Guardian Golem", baseAttack: 30, baseHealth: 300, attackGrowth: 8, healthGrowth: 40, sourceCrate: 4, recycleXpValue: 500, ability: Ability(name: "Stone Form", description: "Massively increases defense.", effect: .defenseUp, baseValue: 30, levelMultiplier: 5, chance: 0.3), criticalChance: 0.05, burnChance: 0.0, thornsDamage: 0.4),
        "character3_crate4": GameCharacter(id: "character3_crate4", name: "Shadow Striker", baseAttack: 50, baseHealth: 180, attackGrowth: 15, healthGrowth: 25, sourceCrate: 4, recycleXpValue: 500, ability: Ability(name: "Assassinate", description: "Deals massive critical damage.", effect: .damage, baseValue: 100, levelMultiplier: 15, chance: 0.2), criticalChance: 0.3, burnChance: 0.0, thornsDamage: 0.0),
        "character4_crate4": GameCharacter(id: "character4_crate4", name: "Paper weight", baseAttack: 35, baseHealth: 220, attackGrowth: 10, healthGrowth: 30, sourceCrate: 4, recycleXpValue: 500, ability: Ability(name: "Time Warp", description: "High chance to stun the enemy.", effect: .stun, baseValue: 0, levelMultiplier: 0, chance: 0.4), criticalChance: 0.9, burnChance: 1.0, thornsDamage: 1.0),
        "character5_crate4": GameCharacter(id: "character5_crate4", name: "Vampiric Viscount", baseAttack: 38, baseHealth: 250, attackGrowth: 11, healthGrowth: 35, sourceCrate: 4, recycleXpValue: 500, ability: Ability(name: "Blood Feast", description: "Drains a large amount of health.", effect: .lifesteal, baseValue: 60, levelMultiplier: 10, chance: 0.3), criticalChance: 0.1, burnChance: 0.0, thornsDamage: 0.1),
        "character6_crate4": GameCharacter(id: "character6_crate4", name: "Warlord of the Wastes", baseAttack: 45, baseHealth: 230, attackGrowth: 14, healthGrowth: 32, sourceCrate: 4, recycleXpValue: 500, ability: Ability(name: "Battle Cry", description: "Increases attack of all allies significantly.", effect: .attackUp, baseValue: 20, levelMultiplier: 4, chance: 0.3), criticalChance: 0.2, burnChance: 0.2, thornsDamage: 0.2)
    ]
    static let allEnemies: [String: GameCharacter] = [
        // World 1
        "enemy_1": GameCharacter(id: "enemy_1", name: "Grumpy Goblin", baseAttack: 8, baseHealth: 40, attackGrowth: 0, healthGrowth: 0, sourceCrate: 0, recycleXpValue: 0, ability: GameDB.defaultAbility, criticalChance: 0.05, burnChance: 0.0, thornsDamage: 0.0),
        "enemy_2": GameCharacter(id: "enemy_2", name: "Angry Orc", baseAttack: 15, baseHealth: 60, attackGrowth: 0, healthGrowth: 0, sourceCrate: 0, recycleXpValue: 0, ability: GameDB.defaultAbility, criticalChance: 0.05, burnChance: 0.0, thornsDamage: 0.0),
        "enemy_3": GameCharacter(id: "enemy_3", name: "Fierce Cyclops", baseAttack: 20, baseHealth: 80, attackGrowth: 0, healthGrowth: 0, sourceCrate: 0, recycleXpValue: 0, ability: GameDB.defaultAbility, criticalChance: 0.05, burnChance: 0.0, thornsDamage: 0.0),
        "boss_enemy": GameCharacter(id: "boss_enemy", name: "The Toaster King", baseAttack: 40, baseHealth: 200, attackGrowth: 0, healthGrowth: 0, sourceCrate: 0, recycleXpValue: 0, ability: GameDB.defaultAbility, criticalChance: 0.1, burnChance: 0.1, thornsDamage: 0.0),
        
        // World 2
        "enemy_4": GameCharacter(id: "enemy_4", name: "Stone Golem", baseAttack: 25, baseHealth: 120, attackGrowth: 0, healthGrowth: 0, sourceCrate: 0, recycleXpValue: 0, ability: GameDB.defaultAbility, criticalChance: 0.05, burnChance: 0.0, thornsDamage: 0.1),
        "enemy_5": GameCharacter(id: "enemy_5", name: "Paper Dragon", baseAttack: 30, baseHealth: 100, attackGrowth: 0, healthGrowth: 0, sourceCrate: 0, recycleXpValue: 0, ability: GameDB.defaultAbility, criticalChance: 0.1, burnChance: 0.2, thornsDamage: 0.0),
        "enemy_6": GameCharacter(id: "enemy_6", name: "Cardboard Knight", baseAttack: 35, baseHealth: 130, attackGrowth: 0, healthGrowth: 0, sourceCrate: 0, recycleXpValue: 0, ability: GameDB.defaultAbility, criticalChance: 0.1, burnChance: 0.0, thornsDamage: 0.15),
        "boss_enemy2": GameCharacter(id: "boss_enemy2", name: "The Corrugator", baseAttack: 50, baseHealth: 300, attackGrowth: 0, healthGrowth: 0, sourceCrate: 0, recycleXpValue: 0, ability: GameDB.defaultAbility, criticalChance: 0.15, burnChance: 0.2, thornsDamage: 0.2),
        
        // World 3
        "enemy_8": GameCharacter(id: "enemy_8", name: "Origami Ninja", baseAttack: 40, baseHealth: 160, attackGrowth: 0, healthGrowth: 0, sourceCrate: 0, recycleXpValue: 0, ability: GameDB.defaultAbility, criticalChance: 0.2, burnChance: 0.1, thornsDamage: 0.0),
        "enemy_10": GameCharacter(id: "enemy_10", name: "Paper Mache Monster", baseAttack: 45, baseHealth: 190, attackGrowth: 0, healthGrowth: 0, sourceCrate: 0, recycleXpValue: 0, ability: GameDB.defaultAbility, criticalChance: 0.1, burnChance: 0.1, thornsDamage: 0.2),
        "enemy_11": GameCharacter(id: "enemy_11", name: "Giga-Golem", baseAttack: 50, baseHealth: 220, attackGrowth: 0, healthGrowth: 0, sourceCrate: 0, recycleXpValue: 0, ability: GameDB.defaultAbility, criticalChance: 0.15, burnChance: 0.0, thornsDamage: 0.25),
        "boss_enemy3": GameCharacter(id: "boss_enemy3", name: "The Grand Folder", baseAttack: 70, baseHealth: 500, attackGrowth: 0, healthGrowth: 0, sourceCrate: 0, recycleXpValue: 0, ability: GameDB.defaultAbility, criticalChance: 0.2, burnChance: 0.3, thornsDamage: 0.3)
    ]
}

// MARK: - Game State Manager
enum GameState: Equatable {
    case mainMenu
    case worldSelect // New State
    case levelSelect
    case store
    case profile
    case army
    case packOpening(crate: Crate)
    case battle(level: Level)
    case postLevelVictory(moneyGained: Int, stars: Int)
    
    static func == (lhs: GameState, rhs: GameState) -> Bool {
        switch (lhs, rhs) {
        case (.mainMenu, .mainMenu),
             (.worldSelect, .worldSelect), // New Case
             (.levelSelect, .levelSelect),
             (.store, .store),
             (.profile, .profile),
             (.army, .army):
            return true
        case (.packOpening(let a), .packOpening(let b)):
            return a.id == b.id
        case (.battle(let a), .battle(let b)):
            return a.id == b.id
        case (.postLevelVictory(let moneyA, let starsA), .postLevelVictory(let moneyB, let starsB)):
            return moneyA == moneyB && starsA == starsB
        default:
            return false
        }
    }
}

class GameStateManager: ObservableObject {
    @Published var navigationStack: [GameState] = [.mainMenu]
    @Published var playerProfile: PlayerProfile
    @Published var levels: [Level] = []
    @Published var selectedWorldId: Int = 1
    
    @Published var hasShownUpgradeTutorial = false
    @Published var hasShownCrateTutorial = false
    
    // Secret Feature State
    @Published var isDoubleRewardsActive = false
    @Published var hasUsedCrateUnlockCheat = false
    private let secretPassphrase = "PAPERPOWER"
    private let unlockAllLevelsPassphrase = "BEAR"
    private let unlockCratesPassphrase = "BLOCKCHAINBULLS"

    var currentState: GameState {
        navigationStack.last ?? .mainMenu
    }
    
    var currentWorldLevels: [Level] {
        let range: ClosedRange<Int>
        switch selectedWorldId {
        case 1: range = 1...50
        case 2: range = 51...100
        case 3: range = 101...150
        default: range = 1...50
        }
        return levels.filter { range.contains($0.id) }
    }
    
    var shouldShowUpgradeNotification: Bool {
        return playerProfile.characterCollection.count > 1 && !hasShownUpgradeTutorial
    }

    var shouldShowCrateTutorial: Bool {
        let cheapestCrateCost = 250
        return playerProfile.paperMoney >= cheapestCrateCost && !hasShownCrateTutorial
    }
    
    init() {
        let initialCharacter = CharacterInstance(characterId: "character_starter")
        self.playerProfile = PlayerProfile(mainCharacterInstanceId: initialCharacter.id, characterCollection: [initialCharacter])
        self.levels = generateAllLevels()
    }
    
    // MARK: - Secret Feature Logic
    func attemptToUnlockSecret(passphrase: String) -> String? {
        let upperPassphrase = passphrase.uppercased()
        
        if upperPassphrase == secretPassphrase {
            isDoubleRewardsActive = true
            return "Success! 2x Rewards Unlocked!"
        }
        
        if upperPassphrase == unlockAllLevelsPassphrase {
            unlockAllLevels()
            return "Success! All levels unlocked!"
        }
        
        if upperPassphrase == unlockCratesPassphrase {
            if hasUsedCrateUnlockCheat {
                return "This cheat has already been used."
            }
            
            grantOneOfEachCrate()
            hasUsedCrateUnlockCheat = true
            return "Success! You've received a character from each crate!"
        }
        
        return nil // Return nil for failure
    }
    
    private func grantOneOfEachCrate() {
        let crateTiers = [1, 2, 3, 4]
        
        for tier in crateTiers {
            let characterPool = GameDB.allCharacters.values.filter { $0.sourceCrate == tier }
            
            if let chosenCharacter = characterPool.randomElement() {
                if let existingCharIndex = playerProfile.characterCollection.firstIndex(where: { $0.characterId == chosenCharacter.id }) {
                    let xpAmount = isDoubleRewardsActive ? chosenCharacter.recycleXpValue * 2 : chosenCharacter.recycleXpValue
                    playerProfile.characterCollection[existingCharIndex].xp += xpAmount
                } else {
                    let newInstance = CharacterInstance(characterId: chosenCharacter.id)
                    playerProfile.characterCollection.append(newInstance)
                }
            }
        }
    }
    
    func unlockAllLevels() {
        for i in levels.indices {
            levels[i].isUnlocked = true
            // Also give a star rating to ensure worlds unlock
            if levels[i].starRating == 0 {
                levels[i].starRating = 1
            }
        }
    }
    
    private func generateAllLevels() -> [Level] {
        var generatedLevels: [Level] = []
        
        for i in 1...150 {
            var enemyIds: [String]
            let difficulty: LevelDifficulty
            let platformAssets: [String]
            
            // Determine world and platform assets based on level ID
            let worldId: Int
            if i <= 50 {
                worldId = 1
                platformAssets = ["level_1", "level_2", "level_3"]
            } else if i <= 100 {
                worldId = 2
                platformAssets = ["level_4", "level_5", "level_6"]
            } else {
                worldId = 3
                platformAssets = ["level_7", "level_8", "level_9"]
            }
            
            // Use modulo to cycle through enemy progression for each world
            let levelInWorld = (i - 1) % 50 + 1
            
            // Assign enemies based on world and level within that world
            switch worldId {
            case 1:
                switch levelInWorld {
                case 1...10: enemyIds = ["enemy_1"]; difficulty = .easy
                case 11...24: enemyIds = ["enemy_2"]; difficulty = .easy
                case 25: enemyIds = ["enemy_1", "enemy_2"]; difficulty = .medium
                case 26...39: enemyIds = ["enemy_3"]; difficulty = .medium
                case 40: enemyIds = ["enemy_3", "enemy_1"]; difficulty = .hard // Changed enemy_4 to enemy_1 for variety
                case 41..<50: enemyIds = ["boss_enemy", "enemy_2"]; difficulty = .hard // Changed enemy_5 to enemy_2
                case 50: enemyIds = ["boss_enemy", "enemy_3", "enemy_2"]; difficulty = .hard // Changed enemy_4, enemy_5
                default: enemyIds = ["enemy_1"]; difficulty = .easy
                }
            case 2:
                switch levelInWorld {
                case 1...10: enemyIds = ["enemy_4"]; difficulty = .easy
                case 11...24: enemyIds = ["enemy_5"]; difficulty = .easy
                case 25: enemyIds = ["enemy_4", "enemy_5"]; difficulty = .medium
                case 26...39: enemyIds = ["enemy_6"]; difficulty = .medium
                case 40: enemyIds = ["enemy_5", "enemy_6"]; difficulty = .hard
                case 41..<50: enemyIds = ["boss_enemy2", "enemy_6"]; difficulty = .hard
                case 50: enemyIds = ["boss_enemy2", "enemy_5", "enemy_6"]; difficulty = .hard
                default: enemyIds = ["enemy_4"]; difficulty = .easy
                }
            case 3:
                switch levelInWorld {
                case 1...10: enemyIds = ["enemy_8"]; difficulty = .easy
                case 11...24: enemyIds = ["enemy_10"]; difficulty = .easy
                case 25: enemyIds = ["enemy_8", "enemy_10"]; difficulty = .medium
                case 26...39: enemyIds = ["enemy_11"]; difficulty = .medium
                case 40: enemyIds = ["enemy_10", "enemy_11"]; difficulty = .hard
                case 41..<50: enemyIds = ["boss_enemy3", "enemy_11"]; difficulty = .hard
                case 50: enemyIds = ["boss_enemy3", "enemy_10", "enemy_11"]; difficulty = .hard
                default: enemyIds = ["enemy_8"]; difficulty = .easy
                }
            default:
                enemyIds = ["enemy_1"]; difficulty = .easy
            }
            
            let isUnlocked = (i == 1)
            let platform = platformAssets.randomElement() ?? "level_1"
            generatedLevels.append(Level(id: i, starRating: 0, enemyIds: enemyIds, isUnlocked: isUnlocked, difficulty: difficulty, platformAssetName: platform))
        }
        return generatedLevels
    }
    
    func selectWorld(_ world: World) {
        self.selectedWorldId = world.id
        
        // Update currentLevelId to the first unlocked level of the selected world
        if let firstUnlockedLevel = currentWorldLevels.first(where: { $0.isUnlocked }) {
            playerProfile.currentLevelId = firstUnlockedLevel.id
        } else if let firstLevel = currentWorldLevels.first {
            // If no levels are unlocked in this world yet, default to the first one.
            // This assumes the world itself is accessible.
            playerProfile.currentLevelId = firstLevel.id
        }
        
        navigateTo(.levelSelect)
    }

    func navigateTo(_ state: GameState) {
        if state == .army && shouldShowUpgradeNotification {
            hasShownUpgradeTutorial = true
        }
        if state == .store && shouldShowCrateTutorial {
            hasShownCrateTutorial = true
        }
        
        guard currentState != state else { return }
        navigationStack.append(state)
    }

    func goBack() {
        if navigationStack.count > 1 {
            _ = navigationStack.popLast()
        }
    }
    
    func returnToLevelSelect() {
        // This now goes back to the world select screen
        navigationStack.removeAll {
            switch $0 {
            case .postLevelVictory, .battle: // Keep level select
                return true
            default:
                return false
            }
        }
    }
    
    func completeLevel(id: Int, stars: Int) -> Int {
        guard let index = levels.firstIndex(where: { $0.id == id }),
              let primaryEnemyId = levels[index].enemyIds.first,
              let enemy = GameDB.allEnemies[primaryEnemyId] else {
            return 0
        }
        
        let levelBonus = 20 * id
        let enemyBonus = (enemy.baseHealth / 4) + (enemy.baseAttack * 2)
        let starMultiplier = 1.0 + (Double(stars) - 1.0) * 0.25
        var moneyGained = Int(Double(levelBonus + enemyBonus) * starMultiplier)
        
        // Apply 2x boost if active
        if isDoubleRewardsActive {
            moneyGained *= 2
        }

        if stars > levels[index].starRating {
            levels[index].starRating = stars
        }
        
        // Apply 2x boost to XP if active
        let xpAmount = isDoubleRewardsActive ? 150 : 75
        addXpToCharacter(instanceId: playerProfile.mainCharacterInstanceId, amount: xpAmount)
        
        playerProfile.paperMoney += moneyGained
        
        let nextLevelId = id + 1
        if nextLevelId <= 150, let nextLevelIndex = levels.firstIndex(where: { $0.id == nextLevelId }) {
            levels[nextLevelIndex].isUnlocked = true
        }
        
        if id == playerProfile.currentLevelId {
            playerProfile.currentLevelId = nextLevelId
        }
        
        return moneyGained
    }
    
    func addPaperMoney(amount: Int) {
        playerProfile.paperMoney += amount
    }
    
    func addXpToCharacter(instanceId: UUID, amount: Int) {
        if let charIndex = playerProfile.characterCollection.firstIndex(where: { $0.id == instanceId }) {
            playerProfile.characterCollection[charIndex].xp += amount
        }
    }

    func upgradeCost(for character: CharacterInstance) -> Int {
        let baseCost = 100.0
        let nextLevel = Double(character.level + 1)
        
        let rarityMultiplier: Double
        switch character.base.sourceCrate {
        case 1: rarityMultiplier = 1.0
        case 2: rarityMultiplier = 2.5
        case 3: rarityMultiplier = 5.0
        default: rarityMultiplier = 1.0
        }
        
        let finalCost = baseCost * pow(nextLevel, 1.5) * rarityMultiplier
        return Int(finalCost)
    }

    func performUpgrade(for instanceId: UUID) {
        guard let charIndex = playerProfile.characterCollection.firstIndex(where: { $0.id == instanceId }) else { return }
        
        while playerProfile.characterCollection[charIndex].canUpgrade {
            let character = playerProfile.characterCollection[charIndex]
            let cost = upgradeCost(for: character)
            
            guard playerProfile.paperMoney >= cost else { break }
            
            playerProfile.paperMoney -= cost
            
            let leftoverXp = character.xp - character.maxXp
            playerProfile.characterCollection[charIndex].level += 1
            playerProfile.characterCollection[charIndex].xp = leftoverXp
        }
    }
}

// MARK: - Helper Views
struct TimeRewardView: View {
    let amount: Int
    @State private var isVisible = false

    var body: some View {
        VStack {
            HStack {
                Image("paper_money")
                    .resizable()
                    .scaledToFit()
                    .frame(height: 40)
                Text("+\(amount)")
                    .minecraftFont(size: 24, color: .green)
            }
            .padding()
            .background(Color.black.opacity(0.7))
            .cornerRadius(20)
            .shadow(radius: 10)
            .offset(y: isVisible ? 0 : -100)
            .opacity(isVisible ? 1 : 0)
            .onAppear {
                withAnimation(.spring()) {
                    isVisible = true
                }
            }
            Spacer()
        }
        .padding(.top, 60)
        .allowsHitTesting(false)
    }
}

struct PaperMoneyView: View {
    let money: Int

    var body: some View {
        HStack {
            Text("\(money)")
                .minecraftFont(size: 24)
            Image("paper_money").resizable().scaledToFit().frame(height: 70)
        }
        .padding(.horizontal, 15).padding(.vertical, 10)
        .shadow(color: .black.opacity(0.3), radius: 5, x: 0, y: 5)
    }
}

struct StarRatingView: View {
    @Binding var rating: Int
    var body: some View {
        HStack { ForEach(0..<3) { i in
            Image("gold_star").resizable().scaledToFit().frame(width: 30, height: 30)
                .grayscale(i < rating ? 0.0 : 1.0).opacity(i < rating ? 1.0 : 0.4)
                .scaleEffect(i < rating ? 1.0 : 0.8)
        }}
    }
}

struct CharacterView: View {
    let characterAssetName: String
    @Binding var isAnimating: Bool
    var body: some View {
        Image(characterAssetName).resizable().aspectRatio(contentMode: .fit).frame(width: 150)
            .rotationEffect(.degrees(isAnimating ? -5 : 5)).offset(y: isAnimating ? -15 : 0)
            .animation(Animation.easeInOut(duration: 2.5).repeatForever(autoreverses: true), value: isAnimating)
    }
}

struct ShootingStarView: View {
    let star: ShootingStar
    @State private var isAnimating = false
    var body: some View {
        Capsule().fill(LinearGradient(gradient: Gradient(colors: [.white, .white.opacity(0)]), startPoint: .top, endPoint: .bottom))
            .frame(width: 3, height: 150).rotationEffect(.degrees(225)).position(isAnimating ? star.endPoint : star.startPoint)
            .onAppear { withAnimation(.linear(duration: star.duration)) { isAnimating = true } }
    }
}

struct ShootingStarLayer: View {
    @State private var stars: [ShootingStar] = []
    let timer = Timer.publish(every: Double.random(in: 3.0...8.0), on: .main, in: .common).autoconnect()
    var body: some View {
        GeometryReader { geometry in
            ZStack {
                ForEach(stars) { star in
                    ShootingStarView(star: star).onAppear {
                        DispatchQueue.main.asyncAfter(deadline: .now() + star.duration) {
                            stars.removeAll { $0.id == star.id }
                        }
                    }
                }
            }
            .onReceive(timer) { _ in
                let startX = CGFloat.random(in: 0...geometry.size.width)
                let newStar = ShootingStar(
                    startPoint: CGPoint(x: startX, y: 0),
                    endPoint: CGPoint(x: startX - 300, y: 600),
                    duration: Double.random(in: 0.5...1.25)
                )
                stars.append(newStar)
            }
        }
    }
}

struct DamageTextView: View {
    let item: DamageText
    
    @State private var yOffset: CGFloat = 0
    @State private var opacity: Double = 1.0
    
    var body: some View {
        Text(item.text)
            .minecraftFont(size: 32, color: item.color)
            .offset(y: yOffset)
            .opacity(opacity)
            .onAppear {
                withAnimation(.easeIn(duration: 1.0)) {
                    yOffset = -80
                    opacity = 0
                }
            }
    }
}

struct HealthBar: View {
    let currentHealth: Int
    let maxHealth: Int
    
    private var healthPercentage: Double { maxHealth > 0 ? Double(currentHealth) / Double(maxHealth) : 0 }
    
    private var barColor: Color {
        if healthPercentage > 0.6 { return .green }
        if healthPercentage > 0.3 { return .yellow }
        return .red
    }
    
    var body: some View {
        ZStack(alignment: .leading) {
            RoundedRectangle(cornerRadius: 8).fill(Color.black.opacity(0.5))
            RoundedRectangle(cornerRadius: 8)
                .fill(barColor)
                .frame(width: 150 * healthPercentage)
                .animation(.easeInOut, value: healthPercentage)
        }.frame(width: 150, height: 20)
         .overlay(Text("\(currentHealth)/\(maxHealth)").minecraftFont(size: 14))
    }
}

struct AttackParticleEffect: View {
    @State private var isAnimating = false

    var body: some View {
        ZStack {
            ForEach(0..<15) { _ in
                Image("attack_particle")
                    .resizable()
                    .scaledToFit()
                    .frame(width: isAnimating ? 40 : 10, height: isAnimating ? 40 : 10)
                    .offset(x: isAnimating ? (CGFloat.random(in: -1...1) * 60) : 0,
                            y: isAnimating ? (CGFloat.random(in: -1...1) * 60) : 0)
                    .opacity(isAnimating ? 0 : 1)
                    .animation(Animation.easeOut(duration: 0.5).delay(Double.random(in: 0...0.1)), value: isAnimating)
            }
        }
        .onAppear {
            isAnimating = true
        }
    }
}

struct BottomBackButtonView: View {
    let action: () -> Void

    var body: some View {
        VStack {
            Spacer()
            HStack {
                Spacer()
                Button(action: action) {
                    Image("back_button")
                        .resizable()
                        .scaledToFit()
                        .frame(width: 150)
                }
                Spacer()
            }
        }
        .frame(maxWidth: .infinity)
        .padding(.bottom, 20)
    }
}

struct DifficultyPill: View {
    let difficulty: LevelDifficulty
    
    private var difficultyColor: Color {
        switch difficulty {
        case .easy: return .green
        case .medium: return .yellow
        case .hard: return .red
        }
    }
    
    var body: some View {
        Text(difficulty.rawValue)
            .minecraftFont(size: 16)
            .padding(.horizontal, 12)
            .padding(.vertical, 5)
            .background(difficultyColor)
            .cornerRadius(20)
            .foregroundColor(.black)
    }
}

struct StatDisplay: View {
    let character: Any
    var isEnemy: Bool = false
    
    private var health: Int {
        if let char = character as? CharacterInstance { return char.health }
        if let char = character as? EnemyInstance { return char.health }
        return 0
    }
    
    private var attack: Int {
        if let char = character as? CharacterInstance { return char.attack }
        if let char = character as? EnemyInstance { return char.attack }
        return 0
    }
    
    var body: some View {
        HStack(spacing: 4) {
            if isEnemy { Spacer() }
            Image(systemName: "heart.fill").foregroundColor(.red).font(.caption)
            Text("\(health)").minecraftFont(size: 14)
            Image(systemName: "flame.fill").foregroundColor(.orange).font(.caption)
            Text("\(attack)").minecraftFont(size: 14)
            if !isEnemy { Spacer() }
        }
        .padding(8)
        .background(.black.opacity(0.6))
        .cornerRadius(10)
    }
}

struct StatPill: View {
    let title: String
    let value: String
    var imageName: String? = nil
    var systemImageName: String? = nil
    
    var body: some View {
        VStack {
            Text(value)
                .minecraftFont(size: 24)
            HStack {
                if let imageName = imageName {
                    Image(imageName).resizable().scaledToFit().frame(height: 22)
                } else if let systemImageName = systemImageName {
                    Image(systemName: systemImageName).font(.system(size: 20)).foregroundColor(.white)
                }
                Text(title)
                    .minecraftFont(size: 16)
            }
        }
        .padding()
        .frame(maxWidth: .infinity)
        .background(Color.black.opacity(0.4))
        .cornerRadius(10)
    }
}

struct StatBar: View {
    let label: String
    let value: Int
    let nextValue: Int
    var body: some View {
        HStack {
            Text(label).minecraftFont(size: 18)
            Text("\(value)").minecraftFont(size: 18)
            Image(systemName: "arrow.right").foregroundColor(.gray)
            Text("\(nextValue)").minecraftFont(size: 18, color: .green)
        }
    }
}

struct NavButtonView: View {
    let imageName: String
    var showNotification: Bool = false
    let action: () -> Void
    
    var body: some View {
        Button(action: action) {
            ZStack(alignment: .topTrailing) {
                Image(imageName)
                    .resizable()
                    .scaledToFit()
                    .frame(width: 350)

                if showNotification {
                    Circle()
                        .fill(Color.red)
                        .frame(width: 30, height: 30)
                        .overlay(
                            Text("!")
                                .minecraftFont(size: 20)
                                .foregroundColor(.white)
                        )
                        .shadow(radius: 5)
                        .offset(x: -20, y: 10)
                }
            }
        }
        .frame(maxWidth: .infinity, maxHeight: .infinity)
    }
}

// MARK: - Main Screen Views

// MODIFICATION: MainMenuView no longer uses a TabView. It directly presents the main content.
struct MainMenuView: View {
    @ObservedObject var gameStateManager: GameStateManager

    var body: some View {
        MainScreenContentView(gameStateManager: gameStateManager)
    }
}

// Extracted the original content to its own view for clarity
struct MainScreenContentView: View {
    @ObservedObject var gameStateManager: GameStateManager
    @State private var isAnimating = false
    @State private var characterJumped = false
    
    // MODIFICATION: Added state to control the new secret menu overlay.
    @State private var showSecretMenuOverlay = false

    var body: some View {
        ZStack {
            Image("background_0").resizable().aspectRatio(contentMode: .fill).edgesIgnoringSafeArea(.all).scaleEffect(1.5).offset(y: isAnimating ? -10 : 10)
            ShootingStarLayer().edgesIgnoringSafeArea(.all)
            
            Image("background_1").resizable().aspectRatio(contentMode: .fit).frame(width: 350, height: 600).offset(y: isAnimating ? 5 : -5)
            VStack {
                Spacer()
                ZStack {
                    Image("background_2").resizable().aspectRatio(contentMode: .fit).frame(width: 380)
                    if let mainChar = gameStateManager.playerProfile.mainCharacter {
                        CharacterView(characterAssetName: mainChar.characterId, isAnimating: $isAnimating)
                            .offset(y: -140).offset(y: characterJumped ? -800 : 0)
                    }
                }
            }.frame(width: 350, height: 600)
            
            VStack {
                // MODIFICATION: Added a long press gesture to the logo to show the secret menu.
                Image("main_logo")
                    .resizable()
                    .scaledToFit()
                    .frame(width: 300)
                    .shadow(radius: 10)
                    .padding(.top, 60)
                    .onLongPressGesture {
                        showSecretMenuOverlay = true
                    }

                Spacer()
                Button(action: {
                    withAnimation(.easeIn(duration: 0.5)) { characterJumped = true }
                    DispatchQueue.main.asyncAfter(deadline: .now() + 0.6) {
                        // Navigate to World Select instead of Level Select
                        withAnimation { gameStateManager.navigateTo(.worldSelect) }
                    }
                }) { Image("start_button").resizable().scaledToFit().frame(width: 250) }
                
                HStack(spacing: 20) {
                    Button(action: { gameStateManager.navigateTo(.army) }) {
                        Image("army_button").resizable().scaledToFit().frame(width: 120)
                    }
                    Button(action: { gameStateManager.navigateTo(.store) }) {
                        Image("crate_button").resizable().scaledToFit().frame(width: 120)
                    }
                }.padding(.top, 10)

            }.padding(.bottom, 40)
            
            // MODIFICATION: The secret menu is now presented as an overlay.
            if showSecretMenuOverlay {
                SecretMenuOverlayView(gameStateManager: gameStateManager, isPresented: $showSecretMenuOverlay)
                    .transition(.opacity.animation(.easeInOut))
            }
            
        }
        .onAppear { withAnimation(Animation.easeInOut(duration: 4.0).repeatForever(autoreverses: true)) { isAnimating = true } }
    }
}

// MARK: - New Secret Menu Overlay
// MODIFICATION: This is the new overlay view, replacing the old full-screen SecretMenuView.
struct SecretMenuOverlayView: View {
    @ObservedObject var gameStateManager: GameStateManager
    @Binding var isPresented: Bool

    @State private var passphraseInput: String = ""
    @State private var message: String = ""
    @State private var messageColor: Color = .red

    var body: some View {
        ZStack {
            // Translucent background that can be tapped to dismiss
            Color.black.opacity(0.75)
                .edgesIgnoringSafeArea(.all)
                .onTapGesture {
                    isPresented = false
                }

            // The actual content view, designed as a pop-up
            VStack(spacing: 15) {
                Text("Secret Menu")
                    .minecraftFont(size: 32)
                    .padding(.bottom, 10)

                // Display active cheats
                if gameStateManager.isDoubleRewardsActive {
                    HStack {
                        Image(systemName: "star.circle.fill")
                            .foregroundColor(.yellow)
                        Text("2x Rewards Active")
                            .minecraftFont(size: 18, color: .yellow)
                    }
                }

                TextField("Enter Code", text: $passphraseInput)
                    .font(.custom("AmericanTypewriter-Bold", size: 20))
                    .foregroundColor(.black)
                    .padding(12)
                    .background(Color.white)
                    .cornerRadius(10)
                    .autocapitalization(.allCharacters)
                    .disableAutocorrection(true)

                Button(action: handleSubmit) {
                    Text("Unlock")
                        .minecraftFont(size: 24)
                        .padding(.vertical, 10)
                        .frame(maxWidth: .infinity)
                        .background(Color.green)
                        .cornerRadius(10)
                }

                if !message.isEmpty {
                    Text(message)
                        .minecraftFont(size: 18, color: messageColor)
                        .multilineTextAlignment(.center)
                        .transition(.opacity)
                }
            }
            .padding(30)
            .background(Color.black.opacity(0.8))
            .cornerRadius(20)
            .padding(.horizontal, 40)
            // Prevents tapping inside the modal from closing it
            .onTapGesture {
                UIApplication.shared.sendAction(#selector(UIResponder.resignFirstResponder), to: nil, from: nil, for: nil)
            }
        }
    }

    // MODIFICATION: Updated handleSubmit for better overlay UX.
    func handleSubmit() {
        // Dismiss keyboard first
        UIApplication.shared.sendAction(#selector(UIResponder.resignFirstResponder), to: nil, from: nil, for: nil)

        if let successMessage = gameStateManager.attemptToUnlockSecret(passphrase: passphraseInput) {
            message = successMessage
            messageColor = .green
            passphraseInput = ""

            // On success, show message then dismiss the overlay
            DispatchQueue.main.asyncAfter(deadline: .now() + 2.0) {
                withAnimation {
                    self.isPresented = false
                }
            }
        } else {
            message = "Incorrect Passphrase."
            messageColor = .red
            passphraseInput = ""

            // On failure, show message for a bit then clear it, keeping the overlay open
            DispatchQueue.main.asyncAfter(deadline: .now() + 3.0) {
                withAnimation {
                    message = ""
                }
            }
        }
    }
}


// MARK: - New World Selection Screen
struct WorldSelectView: View {
    @ObservedObject var gameStateManager: GameStateManager

    // Define the worlds available in the game
    let worlds = [
        World(id: 1, name: "Paper Pastures", imageName: "paper_world", unlockLevel: 1),
        World(id: 2, name: "Cardboard Caverns", imageName: "paper_world2", unlockLevel: 51),
        World(id: 3, name: "Origami Olympus", imageName: "paper_world3", unlockLevel: 101)
    ]

    var body: some View {
        ZStack {
            Image("battle_background")
                .resizable()
                .scaledToFill()
                .edgesIgnoringSafeArea(.all)

            VStack(spacing: 0) {
                Text("Select a World")
                    .minecraftFont(size: 40)
                    .padding(.top, 80)
                    .padding(.bottom, 20)

                TabView {
                    ForEach(worlds) { world in
                        let highestLevelCompleted = (gameStateManager.levels.filter { $0.starRating > 0 }.map { $0.id }.max() ?? 0)
                        let isUnlocked = highestLevelCompleted + 1 >= world.unlockLevel
                        
                        WorldNodeView(
                            world: world,
                            isUnlocked: isUnlocked,
                            action: {
                                if isUnlocked {
                                    gameStateManager.selectWorld(world)
                                }
                            }
                        )
                        .tag(world.id)
                    }
                }
                .tabViewStyle(.page(indexDisplayMode: .always))
                .padding(.bottom, 60)
            }
            
            BottomBackButtonView {
                gameStateManager.goBack()
            }
        }
    }
}

struct WorldNodeView: View {
    let world: World
    let isUnlocked: Bool
    let action: () -> Void

    @State private var isFloating = false

    var body: some View {
        Button(action: action) {
            VStack(spacing: 15) {
                Spacer()
                Image(world.imageName)
                    .resizable()
                    .scaledToFit()
                    .frame(width: 300)
                    .grayscale(isUnlocked ? 0 : 1.0) // Grayscale if locked
                    .opacity(isUnlocked ? 1.0 : 0.5) // Dim if locked
                    .shadow(color: isUnlocked ? .yellow.opacity(0.5) : .clear, radius: 10)
                    .offset(y: isFloating ? -10 : 10)


                Text(world.name)
                    .minecraftFont(size: 28)

                if !isUnlocked {
                    Text("Unlock at Level \(world.unlockLevel)")
                        .minecraftFont(size: 18, color: .gray)
                }
                Spacer()
                Spacer()
            }
        }
        .disabled(!isUnlocked)
        .onAppear {
            // Add a subtle floating animation
            withAnimation(Animation.easeInOut(duration: Double.random(in: 2.5...4.0)).repeatForever(autoreverses: true)) {
                isFloating = true
            }
        }
    }
}


struct LevelNodeView: View {
    let level: Level
    @ObservedObject var gameStateManager: GameStateManager
    
    @State private var isFloating = false
    @State private var animatedStars = 0
    @State private var platformTiltAngle: Double = 0
    @State private var characterLanded = false
    
    private var playerChar: CharacterInstance { gameStateManager.playerProfile.mainCharacter! }
    private var enemyInstance: EnemyInstance { EnemyInstance(id: level.enemyIds.first!, levelId: level.id) }
    
    var body: some View {
        Button(action: {
            if level.isUnlocked {
                gameStateManager.navigateTo(.battle(level: level))
            }
        }) {
            ZStack {
                VStack {
                    Spacer()
                    ZStack {
                        Image(level.platformAssetName)
                            .resizable()
                            .scaledToFit()
                            .frame(width: 350)
                    }
                    .rotationEffect(.degrees(platformTiltAngle))
                    .offset(y: isFloating ? -10 : 10)
                    .offset(y: level.platformAssetName == "level_3" ? 40 : 0)
                }
                
                VStack {
                    StarRatingView(rating: $animatedStars)
                        .padding(.top, 100)

                    DifficultyPill(difficulty: level.difficulty)
                    Text("Level \(level.id)").minecraftFont()

                    Spacer()

                    HStack(spacing: 10) {
                        Image(playerChar.characterId)
                            .resizable().scaledToFit().frame(width: 120)
                            .offset(y: characterLanded ? 0 : -400)
                        
                        Image(enemyInstance.id)
                            .resizable().scaledToFit().frame(height: 130)
                    }
                    
                    Spacer()
                    
                    Spacer().frame(height: 150)
                }
            }
        }
        .buttonStyle(PlainButtonStyle())
        .onAppear {
            withAnimation(Animation.easeInOut(duration: 3.0).repeatForever(autoreverses: true)) { isFloating = true }
            animateStars(to: level.starRating)
            if gameStateManager.playerProfile.currentLevelId == level.id {
                triggerLandingAnimation()
            }
        }
        .onChange(of: gameStateManager.playerProfile.currentLevelId) { newId in
            if newId == level.id {
                characterLanded = false
                triggerLandingAnimation()
            }
        }
    }
    
    private func triggerLandingAnimation() {
        DispatchQueue.main.asyncAfter(deadline: .now() + 0.2) {
            withAnimation(.interpolatingSpring(mass: 1, stiffness: 100, damping: 12, initialVelocity: 0)) {
                characterLanded = true
            }
            withAnimation(.spring(response: 0.3, dampingFraction: 0.3).delay(0.2)) {
                platformTiltAngle = -7
            }
            DispatchQueue.main.asyncAfter(deadline: .now() + 0.8) {
                withAnimation(.spring()) {
                    platformTiltAngle = 0
                }
            }
        }
    }
    
    private func animateStars(to newRating: Int) {
        animatedStars = 0
        for i in 0..<newRating {
            DispatchQueue.main.asyncAfter(deadline: .now() + Double(i) * 0.3) {
                withAnimation(.spring(response: 0.4, dampingFraction: 0.5)) { animatedStars += 1 }
            }
        }
    }
}

struct LevelSelectView: View {
    @ObservedObject var gameStateManager: GameStateManager
    @State private var currentLevelSelection: Int

    init(gameStateManager: GameStateManager) {
        self.gameStateManager = gameStateManager
        self._currentLevelSelection = State(initialValue: gameStateManager.playerProfile.currentLevelId)
    }

    var body: some View {
        let showUpgradeNotif = gameStateManager.shouldShowUpgradeNotification
        let showCrateNotif = gameStateManager.shouldShowCrateTutorial
        
        ZStack {
            Image("battle_background")
                .resizable()
                .scaledToFill()
                .edgesIgnoringSafeArea(.all)

            VStack(spacing: 0) {
                TabView {
                    NavButtonView(imageName: "army_button", showNotification: showUpgradeNotif, action: { gameStateManager.navigateTo(.army) })
                    NavButtonView(imageName: "crate_button", showNotification: showCrateNotif, action: { gameStateManager.navigateTo(.store) })
                }
                .frame(height: 150)
                .tabViewStyle(.page(indexDisplayMode: .never))
                .padding(.top, 60)

                TabView(selection: $currentLevelSelection) {
                    ForEach(gameStateManager.currentWorldLevels) { level in
                        LevelNodeView(level: level, gameStateManager: gameStateManager)
                            .tag(level.id)
                            .grayscale(level.isUnlocked ? 0 : 1.0)
                            .opacity(level.isUnlocked ? 1.0 : 0.6)
                            .allowsHitTesting(level.isUnlocked)
                    }
                }
                .tabViewStyle(.page(indexDisplayMode: .always))
                .padding(.bottom, 60)
            }
            
            VStack {
                HStack {
                    Spacer()
                    PaperMoneyView(money: gameStateManager.playerProfile.paperMoney)
                    Spacer()
                }
                .padding(.top)
                Spacer()
            }
            
            BottomBackButtonView {
                gameStateManager.goBack()
            }
        }
        .onChange(of: gameStateManager.playerProfile.currentLevelId) { newId in
            withAnimation {
                currentLevelSelection = newId
            }
        }
    }
}

struct StoreView: View {
    @ObservedObject var gameStateManager: GameStateManager
    // MODIFICATION: Added the new Legendary Crate to the list.
    let crates = [
        Crate(name: "Common Crate", imageName: "crate_1", cost: 250, tier: 1),
        Crate(name: "Rare Crate", imageName: "crate_2", cost: 1000, tier: 2),
        Crate(name: "Epic Crate", imageName: "crate_3", cost: 3000, tier: 3),
        Crate(name: "Legendary Crate", imageName: "crate_4", cost: 7500, tier: 4)
    ]
    
    var body: some View {
        ZStack(alignment: .top) {
            Image("crate_background").resizable().scaledToFill().edgesIgnoringSafeArea(.all)
            
            VStack(spacing: 0) {
                Text("Crate Store").minecraftFont()
                    .padding(.top, 80)
                    .padding(.bottom)

                TabView {
                    ForEach(crates) { crate in
                        // MODIFICATION: Added a check to show the Legendary Crate only after level 50.
                        let highestLevelCompleted = (gameStateManager.levels.filter { $0.starRating > 0 }.map { $0.id }.max() ?? 0)
                        if crate.tier <= 3 || (crate.tier == 4 && highestLevelCompleted >= 50) {
                            VStack(spacing: 20) {
                                Spacer()
                                Image(crate.imageName).resizable().scaledToFit().frame(height: 200)
                                Text(crate.name).minecraftFont()
                                Text("Contains 1 Character").minecraftFont(size: 20)
                                Spacer().frame(height: 20)
                                Button(action: {
                                    if gameStateManager.playerProfile.paperMoney >= crate.cost {
                                        gameStateManager.playerProfile.paperMoney -= crate.cost
                                        gameStateManager.navigateTo(.packOpening(crate: crate))
                                    }
                                }) {
                                    HStack {
                                        Text("\(crate.cost)").minecraftFont(size: 22)
                                        Image("paper_money").resizable().scaledToFit().frame(height: 25)
                                    }
                                    .padding(.horizontal, 30).padding(.vertical, 15)
                                    .background(gameStateManager.playerProfile.paperMoney >= crate.cost ? Color.yellow : Color.gray)
                                    .foregroundColor(.black).cornerRadius(15)
                                }
                                .disabled(gameStateManager.playerProfile.paperMoney < crate.cost)
                                Spacer()
                            }
                            .padding(.bottom, 80)
                        }
                    }
                }
                .tabViewStyle(.page)
            }
            
            VStack {
                HStack {
                    Spacer()
                    PaperMoneyView(money: gameStateManager.playerProfile.paperMoney)
                    Spacer()
                }
                .padding(.top)
                Spacer()
            }
            
            BottomBackButtonView {
                gameStateManager.goBack()
            }
        }
    }
}

struct ProfileView: View {
    @ObservedObject var gameStateManager: GameStateManager
    private let statColumns = [GridItem(.adaptive(minimum: 150))]

    var body: some View {
        ZStack {
            Image("battle_background")
                .resizable()
                .scaledToFill()
                .edgesIgnoringSafeArea(.all)

            VStack(spacing: 0) {
                HStack {
                    Button(action: { gameStateManager.goBack() }) {
                        Image("back_button").resizable().scaledToFit().frame(width: 90)
                    }
                    Spacer()
                    Text("Your Profile").minecraftFont()
                    Spacer()
                    Image("back_button").resizable().scaledToFit().frame(width: 90).opacity(0)
                }
                .padding(.horizontal)
                .padding(.top, 50)
                .padding(.bottom, 10)
                
                ScrollView {
                    VStack(spacing: 24) {
                        VStack {
                            Image(gameStateManager.playerProfile.profileImageName)
                                .resizable()
                                .scaledToFit()
                                .frame(width: 120, height: 120)
                                .clipShape(Circle())
                                .overlay(Circle().stroke(Color.yellow, lineWidth: 4))
                                .shadow(radius: 10)
                            
                            Text(gameStateManager.playerProfile.displayName)
                                .minecraftFont(size: 36)
                            
                            Text(gameStateManager.playerProfile.bio)
                                .font(.custom("AmericanTypewriter", size: 18))
                                .foregroundColor(.white.opacity(0.8))
                                .multilineTextAlignment(.center)
                                .padding(.horizontal)
                        }
                        .padding()
                        .frame(maxWidth: .infinity)
                        .background(.black.opacity(0.4))
                        .cornerRadius(20)
                        
                        if let mainChar = gameStateManager.playerProfile.mainCharacter {
                            VStack(spacing: 10) {
                                Text("Main Character")
                                    .minecraftFont(size: 24)
                                
                                HStack {
                                    Image(mainChar.characterId)
                                        .resizable()
                                        .scaledToFit()
                                        .frame(height: 100)
                                    
                                    VStack(alignment: .leading) {
                                        Text(mainChar.name)
                                            .minecraftFont(size: 22)
                                        Text("Lvl \(mainChar.level)")
                                            .minecraftFont(size: 18, color: .yellow)
                                        StatDisplay(character: mainChar)
                                    }
                                }
                            }
                            .padding()
                            .frame(maxWidth: .infinity)
                            .background(.black.opacity(0.4))
                            .cornerRadius(20)
                        }
                        
                        VStack {
                            Text("Hero Stats")
                                .minecraftFont(size: 24)
                            
                            LazyVGrid(columns: statColumns, spacing: 16) {
                                StatPill(title: "Paper Money", value: "\(gameStateManager.playerProfile.paperMoney)", imageName: "paper_money")
                                StatPill(title: "Levels Won", value: "\(gameStateManager.levels.filter { $0.starRating > 0 }.count)", systemImageName: "star.fill")
                                StatPill(title: "Characters", value: "\(gameStateManager.playerProfile.characterCollection.count)", systemImageName: "person.3.fill")
                                StatPill(title: "Current Level", value: "\(gameStateManager.playerProfile.currentLevelId)", systemImageName: "flag.fill")
                            }
                        }
                        .padding()
                        .frame(maxWidth: .infinity)
                        .background(.black.opacity(0.4))
                        .cornerRadius(20)

                    }
                    .padding(.horizontal)
                }
            }
        }
    }
}

// MARK: - Army Carousel Screen
// MODIFICATION: Removed the "XP to Next Level" text from the XPBarView.
struct XPBarView: View {
    let currentXP: Int
    let maxXP: Int
    
    private var progress: CGFloat {
        return maxXP > 0 ? CGFloat(currentXP) / CGFloat(maxXP) : 0
    }
    
    var body: some View {
        VStack(alignment: .leading, spacing: 2) {
            ZStack {
                RoundedRectangle(cornerRadius: 4)
                    .fill(Color.black.opacity(0.5))

                GeometryReader { geometry in
                    RoundedRectangle(cornerRadius: 4)
                        .fill(
                            LinearGradient(
                                gradient: Gradient(colors: [Color(red: 0.6, green: 0, blue: 1), .purple]),
                                startPoint: .leading,
                                endPoint: .trailing
                            )
                        )
                        .frame(width: geometry.size.width * progress)
                        .animation(.easeInOut, value: progress)
                }

                Text("\(currentXP) / \(maxXP)")
                    .minecraftFont(size: 10)
            }
            .frame(height: 13)
        }
    }
}

// NEW VIEW: This view displays icons for special abilities like Burn and Thorns.
struct AbilityIconView: View {
    let character: GameCharacter

    var body: some View {
        HStack(spacing: 15) {
            if character.burnChance > 0 {
                HStack(spacing: 4) {
                    Image(systemName: "flame.fill")
                        .foregroundColor(.orange)
                    Text("Burn")
                        .minecraftFont(size: 14, color: .orange)
                }
                .padding(8)
                .background(Color.black.opacity(0.5))
                .cornerRadius(10)
            }
            if character.thornsDamage > 0 {
                HStack(spacing: 4) {
                    Image(systemName: "shield.lefthalf.filled")
                        .foregroundColor(.purple)
                    Text("Thorns")
                        .minecraftFont(size: 14, color: .purple)
                }
                .padding(8)
                .background(Color.black.opacity(0.5))
                .cornerRadius(10)
            }
        }
    }
}

struct CharacterPageView: View {
    @ObservedObject var gameStateManager: GameStateManager
    let character: CharacterInstance

    var body: some View {
        VStack(spacing: 15) {
            Spacer()
            
            Text(character.name)
                .minecraftFont(size: 40)
            
            Text("Level \(character.level)")
                .minecraftFont(size: 24, color: .yellow)
            
            // MODIFICATION: Added the AbilityIconView to show special abilities.
            AbilityIconView(character: character.base)
                .padding(.bottom, 10)

            Image(character.characterId)
                .resizable()
                .scaledToFit()
                .frame(maxHeight: 250)
                .shadow(radius: 10)

            VStack {
                StatBar(label: "HP", value: character.health, nextValue: character.health + character.base.healthGrowth)
                StatBar(label: "DMG", value: character.attack, nextValue: character.attack + character.base.attackGrowth)
            }
            .padding()
            .background(Material.regular)
            .cornerRadius(15)

            VStack(spacing: 15) {
                xpAndUpgradeView(for: character)
                setAsMainButton(for: character)
            }
            .padding(.horizontal)

            Button(action: { gameStateManager.goBack() }) {
                Image("back_button")
                    .resizable()
                    .scaledToFit()
                    .frame(width: 200)
            }
            .padding(.top, 5)

            Spacer()
        }
        .padding(.horizontal, 20)
    }

    @ViewBuilder
    private func xpAndUpgradeView(for character: CharacterInstance) -> some View {
        if character.canUpgrade {
            let cost = gameStateManager.upgradeCost(for: character)
            let canAfford = gameStateManager.playerProfile.paperMoney >= cost
            
            Button(action: {
                gameStateManager.performUpgrade(for: character.id)
            }) {
                HStack {
                    Text("Upgrade for \(cost)")
                    Image("paper_money").resizable().scaledToFit().frame(height: 20)
                }
                .minecraftFont(size: 18, color: .white)
                .frame(maxWidth: .infinity)
                .padding(10)
                .background(canAfford ? Color.green : Color.gray)
                .cornerRadius(8)
            }
            .disabled(!canAfford)
            .shadow(color: canAfford ? .green : .clear, radius: 5)
        } else {
            XPBarView(currentXP: character.xp, maxXP: character.maxXp)
        }
    }
    
    @ViewBuilder
    private func setAsMainButton(for character: CharacterInstance) -> some View {
        let isMainCharacter = gameStateManager.playerProfile.mainCharacterInstanceId == character.id
        
        Button(action: { gameStateManager.playerProfile.mainCharacterInstanceId = character.id }) {
            Label {
                Text("Set as Main")
            } icon: {
                Image(systemName: "star.fill")
            }
            .minecraftFont(size: 22, color: isMainCharacter ? .yellow : .white)
            .frame(maxWidth: .infinity)
            .padding(15)
        }
        .background(Color.clear)
        .cornerRadius(8)
        .disabled(isMainCharacter)
    }
}

struct ArmyView: View {
    @ObservedObject var gameStateManager: GameStateManager
    @State private var selectedCharacterId: UUID

    init(gameStateManager: GameStateManager) {
        self.gameStateManager = gameStateManager
        _selectedCharacterId = State(initialValue: gameStateManager.playerProfile.mainCharacterInstanceId)
    }

    var body: some View {
        ZStack(alignment: .top) {
            Image("army_background")
                .resizable()
                .scaledToFill()
                .edgesIgnoringSafeArea(.all)
            
            Color.black.opacity(0.3).edgesIgnoringSafeArea(.all)
            
            VStack(spacing: 0) {
                HStack {
                    Spacer()
                    Text("My Army").minecraftFont(size: 32)
                    Spacer()
                }
                .padding(.top, 50)
                
                TabView(selection: $selectedCharacterId) {
                    ForEach(gameStateManager.playerProfile.characterCollection) { character in
                        CharacterPageView(gameStateManager: gameStateManager, character: character)
                            .tag(character.id)
                    }
                }
                .tabViewStyle(.page(indexDisplayMode: .always))
            }
        }
        .ignoresSafeArea(edges: .bottom)
    }
}

// MARK: - Crate Opening Screen
enum CrateAnimationStep {
    case initial, shaking, revealing, finished
}

struct CrateOpeningParticles: View {
    @State private var isAnimating: Bool = false
    var body: some View {
        ZStack {
            ForEach(0..<25) { _ in
                Circle()
                    .fill(
                        LinearGradient(
                            gradient: Gradient(colors: [.yellow, .orange, .yellow.opacity(0)]),
                            startPoint: .center,
                            endPoint: .bottom
                        )
                    )
                    .frame(width: .random(in: 10...50), height: .random(in: 10...50))
                    .scaleEffect(isAnimating ? CGFloat.random(in: 1.5...3.0) : 1)
                    .offset(x: isAnimating ? .random(in: -250...250) : 0, y: isAnimating ? .random(in: -250...250) : 0)
                    .opacity(isAnimating ? 0 : 1)
            }
        }
        .onAppear {
            withAnimation(Animation.spring(response: 0.5, dampingFraction: 0.5).delay(0.1)) {
                isAnimating = true
            }
        }
    }
}

struct PackOpeningView: View {
    @ObservedObject var gameStateManager: GameStateManager
    let crate: Crate

    @State private var animationStep: CrateAnimationStep = .initial
    @State private var revealedCharacter: GameCharacter? = nil
    @State private var isDuplicate: Bool = false
    @State private var rotation: Double = 0
    @State private var scale: CGFloat = 1.0
    @State private var xpGainedOnDuplicate: Int = 0

    var body: some View {
        ZStack {
            Image("crate_background").resizable().scaledToFill().edgesIgnoringSafeArea(.all).blur(radius: 5)
            Color.black.opacity(0.4).edgesIgnoringSafeArea(.all)
            
            VStack(spacing: 30) {
                if let character = revealedCharacter, animationStep == .revealing || animationStep == .finished {
                    // Character Reveal Area
                    ZStack {
                        if animationStep == .revealing {
                            CrateOpeningParticles()
                            RadialGradient(colors: [.yellow.opacity(0.8), .yellow.opacity(0)], center: .center, startRadius: 50, endRadius: 300)
                                .scaleEffect(scale * 1.5)
                        }
                        
                        Image(character.id)
                            .resizable().scaledToFit().frame(height: 300)
                            .scaleEffect(scale)
                            .shadow(color: .yellow, radius: 10)
                    }
                    
                    if animationStep == .finished {
                        Text(character.name).minecraftFont(size: 40)
                        
                        // MODIFICATION: Added the AbilityIconView to show special abilities on reveal.
                        AbilityIconView(character: character)
                        
                        if isDuplicate {
                            Text("DUPLICATE!\n+\(xpGainedOnDuplicate) XP").minecraftFont(size: 24, color: .green)
                                .multilineTextAlignment(.center)
                        } else {
                             Text("NEW CHARACTER!").minecraftFont(size: 24, color: .cyan)
                        }

                        Button(action: { gameStateManager.goBack() }) {
                            Text("Continue")
                                .minecraftFont(size: 28)
                                .padding()
                                .background(Color.blue)
                                .cornerRadius(10)
                        }
                    }
                    
                } else {
                    // Crate Area
                    Image(crate.imageName)
                        .resizable().scaledToFit().frame(height: 250)
                        .rotationEffect(.degrees(rotation))
                        .scaleEffect(scale)
                    
                    if animationStep == .initial {
                        Button(action: openCrate) {
                            Text("Tap to Open")
                                .minecraftFont(size: 28)
                                .padding()
                                .background(Color.green)
                                .cornerRadius(10)
                        }
                    }
                }
            }
            .padding()
        }
    }

    func openCrate() {
        let characterPool = GameDB.allCharacters.values.filter { $0.sourceCrate == crate.tier }
        guard let chosenCharacter = characterPool.randomElement() else {
            gameStateManager.goBack()
            return
        }
        
        self.revealedCharacter = chosenCharacter

        if let existingChar = gameStateManager.playerProfile.characterCollection.first(where: { $0.characterId == chosenCharacter.id }) {
            self.isDuplicate = true
            let xpAmount = gameStateManager.isDoubleRewardsActive ? chosenCharacter.recycleXpValue * 2 : chosenCharacter.recycleXpValue
            self.xpGainedOnDuplicate = xpAmount
            gameStateManager.addXpToCharacter(instanceId: existingChar.id, amount: xpAmount)
        } else {
            self.isDuplicate = false
            let newInstance = CharacterInstance(characterId: chosenCharacter.id)
            gameStateManager.playerProfile.characterCollection.append(newInstance)
        }

        withAnimation { animationStep = .shaking }
        withAnimation(Animation.linear(duration: 0.1).repeatCount(10, autoreverses: true)) {
            rotation = 5
        }
        
        DispatchQueue.main.asyncAfter(deadline: .now() + 1.2) {
            rotation = 0
            withAnimation(.spring(response: 0.4, dampingFraction: 0.5)) {
                animationStep = .revealing
                scale = 0
            }
            
            DispatchQueue.main.asyncAfter(deadline: .now() + 0.4) {
                scale = 0
                withAnimation(.spring(response: 0.6, dampingFraction: 0.6)) {
                    scale = 1.1
                }
                
                DispatchQueue.main.asyncAfter(deadline: .now() + 0.3) {
                    withAnimation(.spring()) {
                        scale = 1.0
                    }
                }
            }
        }
        
        DispatchQueue.main.asyncAfter(deadline: .now() + 2.5) {
            withAnimation {
                animationStep = .finished
            }
        }
    }
}

struct PostLevelVictoryView: View {
    @ObservedObject var gameStateManager: GameStateManager
    let moneyGained: Int
    let stars: Int
    var body: some View {
        ZStack {
            Image("battle_background")
                .resizable()
                .scaledToFill()
                .edgesIgnoringSafeArea(.all)
            
            Color.black.opacity(0.4).edgesIgnoringSafeArea(.all)

            VStack {
                Spacer()
                VStack(spacing: 30) {
                     Text("Victory!")
                        .minecraftFont(size: 60, color: .yellow)
                    
                     VStack {
                         Text("You earned:")
                              .minecraftFont(size: 24)
                         HStack {
                              Text("\(moneyGained)")
                                   .minecraftFont(size: 32, color: .green)
                              Image("paper_money")
                                   .resizable().scaledToFit().frame(height: 40)
                         }
                     }

                     StarRatingView(rating: .constant(stars))
                }
                .padding(40)
                .background(Material.regular)
                .cornerRadius(20)
                .shadow(radius: 10)
                Spacer()
            }
            
            BottomBackButtonView { gameStateManager.returnToLevelSelect() }
        }
    }
}

// MARK: - Battle System
struct BattleView: View {
    @ObservedObject var gameStateManager: GameStateManager
    let level: Level
    
    // Helper struct for attack outcomes
    private struct AttackResult {
        let damage: Int
        let didMiss: Bool
        let didCrit: Bool
        let didStun: Bool
        let didBurn: Bool
    }
    
    // Battle State
    @State private var playerHealth: Int
    @State private var enemyHealth: Int
    @State private var isPlayerTurn: Bool = true
    @State private var damageNumbers: [DamageText] = []
    @State private var battleTimer = Timer.publish(every: 1.75, on: .main, in: .common).autoconnect()
    @State private var isBattleOver = false
    @State private var isPerformingMultiHit = false

    // Animation Triggers
    @State private var showPlayerAttack = false
    @State private var showEnemyAttack = false
    
    private var playerChar: CharacterInstance { gameStateManager.playerProfile.mainCharacter! }
    private var enemyInstance: EnemyInstance { EnemyInstance(id: level.enemyIds.first!, levelId: level.id) }
    
    private var worldId: Int {
        if level.id <= 50 { return 1 }
        if level.id <= 100 { return 2 }
        return 3
    }

    private var battleBackgroundName: String {
        switch worldId {
        case 2:
            return "battle_world2"
        case 3:
            return "battle_background4"
        default:
            return "battle_background2"
        }
    }
    
    init(gameStateManager: GameStateManager, level: Level) {
        self.gameStateManager = gameStateManager
        self.level = level
        let player = gameStateManager.playerProfile.mainCharacter!
        _playerHealth = State(initialValue: player.health)
        
        let enemy = EnemyInstance(id: level.enemyIds.first!, levelId: level.id)
        _enemyHealth = State(initialValue: enemy.health)
    }

    var body: some View {
        GeometryReader { geometry in
            ZStack {
                Image("battle_background")
                    .resizable()
                    .scaledToFill()
                    .edgesIgnoringSafeArea(.all)
                
                VStack {
                    Spacer()
                    Image(battleBackgroundName)
                        .resizable()
                        .scaledToFit()
                        .scaleEffect(worldId == 3 ? 2.6 : (worldId == 2 ? 3.0 : 1.0))
                        .offset(y: 25)
                }
                .frame(maxWidth: .infinity, maxHeight: .infinity)


                HStack(alignment: .bottom, spacing: 40) {
                    VStack {
                        Image(playerChar.characterId)
                            .resizable().scaledToFit().frame(width: 150)
                            .offset(x: showPlayerAttack ? 50 : 0)
                        Text(playerChar.name).minecraftFont(size: 20)
                        HealthBar(currentHealth: playerHealth, maxHealth: playerChar.health)
                    }
                    .overlay(showPlayerAttack ? AttackParticleEffect().offset(x: 50) : nil)
                    
                    VStack {
                        Image(enemyInstance.id)
                            .resizable().scaledToFit().frame(width: 150)
                            .offset(x: showEnemyAttack ? -50 : 0)
                        Text(enemyInstance.name).minecraftFont(size: 20)
                        HealthBar(currentHealth: enemyHealth, maxHealth: enemyInstance.health)
                    }
                     .overlay(showEnemyAttack ? AttackParticleEffect().offset(x: -50) : nil)
                }
                .position(x: geometry.size.width / 2, y: geometry.size.height * 0.75)
                
                ZStack {
                    ForEach(damageNumbers) { item in
                        DamageTextView(item: item)
                            .position(
                                x: item.isPlayerDamage ? geometry.size.width * 0.3 : geometry.size.width * 0.7,
                                y: geometry.size.height * 0.6
                            )
                    }
                }
            }
        }
        .onAppear(perform: setupBattle)
        .onReceive(battleTimer) { _ in
            guard !isBattleOver, !isPerformingMultiHit else {
                if isBattleOver {
                    battleTimer.upstream.connect().cancel()
                }
                return
            }
            
            if isPlayerTurn {
                playerAttack()
            } else {
                enemyTurn()
            }
        }
        .onDisappear {
            battleTimer.upstream.connect().cancel()
        }
    }
    
    func setupBattle() {
        self.playerHealth = playerChar.health
        self.enemyHealth = enemyInstance.health
    }

    // MODIFICATION: This function now calculates outcomes for crit and burn based on the character's stats.
    private func calculateAttackOutcome(attackPower: Int, criticalChance: Double, burnChance: Double) -> AttackResult {
        if Double.random(in: 0...1) < 0.1 { // 10% miss chance
            return AttackResult(damage: 0, didMiss: true, didCrit: false, didStun: false, didBurn: false)
        }

        var finalDamage = attackPower
        var didCrit = false
        if Double.random(in: 0...1) < criticalChance {
            didCrit = true
            finalDamage = Int(Double(finalDamage) * 1.5)
        }

        let didStun = Double.random(in: 0...1) < 0.05 // 5% stun chance
        let didBurn = Double.random(in: 0...1) < burnChance

        return AttackResult(damage: finalDamage, didMiss: false, didCrit: didCrit, didStun: didStun, didBurn: didBurn)
    }

    // MODIFICATION: Player attack now uses the character's specific chances and applies burn damage.
    func playerAttack() {
        withAnimation(.easeInOut(duration: 0.2)) { showPlayerAttack = true }
        DispatchQueue.main.asyncAfter(deadline: .now() + 0.2) {
            withAnimation(.easeInOut(duration: 0.2)) { showPlayerAttack = false }
        }
        
        let result = calculateAttackOutcome(attackPower: playerChar.attack, criticalChance: playerChar.base.criticalChance, burnChance: playerChar.base.burnChance)

        if result.didMiss {
            damageNumbers.append(DamageText(text: "Miss!", color: .gray, isPlayerDamage: false))
            isPlayerTurn = false
            return
        }
        
        var totalDamage = result.damage
        if result.didBurn {
            totalDamage += Int(Double(playerChar.attack) * 0.5) // Burn adds 50% of attack as extra damage
            damageNumbers.append(DamageText(text: "Burn!", color: .orange, isPlayerDamage: false))
        }
        
        enemyHealth -= totalDamage
        
        if result.didCrit {
            damageNumbers.append(DamageText(text: "CRITICAL!\n-\(totalDamage)", color: .orange, isPlayerDamage: false))
        } else {
            damageNumbers.append(DamageText(text: "-\(totalDamage)", color: .red, isPlayerDamage: false))
        }

        if checkEnemyDefeat() { return }
        
        if result.didStun {
            damageNumbers.append(DamageText(text: "Stunned!", color: .cyan, isPlayerDamage: false))
        } else {
            isPlayerTurn = false
        }
    }
    
    // MODIFICATION: Enemy turn now checks for thorns and applies damage back to the enemy if the player has it.
    func enemyTurn() {
        withAnimation(.easeInOut(duration: 0.2)) { showEnemyAttack = true }
        DispatchQueue.main.asyncAfter(deadline: .now() + 0.2) {
            withAnimation(.easeInOut(duration: 0.2)) { showEnemyAttack = false }
        }
        
        if playerChar.base.thornsDamage > 0 {
            let thornsDmg = Int(Double(enemyInstance.attack) * playerChar.base.thornsDamage)
            enemyHealth -= thornsDmg
            damageNumbers.append(DamageText(text: "Thorns! -\(thornsDmg)", color: .purple, isPlayerDamage: false))
            if checkEnemyDefeat() { return }
        }
        
        switch worldId {
        case 2:
            // Web Knock (30% chance)
            if Int.random(in: 1...100) <= 30 {
                let damage = Int(Double(enemyInstance.attack) * 0.75)
                playerHealth -= damage
                damageNumbers.append(DamageText(text: "Web Knock! -\(damage)", color: .purple, isPlayerDamage: true))
                if checkPlayerDefeat() { return }
                isPlayerTurn = true
                return
            }
        case 3:
            // Origami (5% chance)
            if Int.random(in: 1...100) <= 5 {
                performOrigamiAttack()
                return
            }
            // Paper Cut (15% chance)
            if Int.random(in: 1...100) <= 15 {
                let damage = Int(Double(enemyInstance.attack) * 1.75)
                playerHealth -= damage
                damageNumbers.append(DamageText(text: "Paper Cut! -\(damage)", color: .orange, isPlayerDamage: true))
                if checkPlayerDefeat() { return }
                isPlayerTurn = true
                return
            }
        default:
            break
        }
        
        // Default attack for all worlds if no special move triggers
        performDefaultEnemyAttack()
    }
    
    func performDefaultEnemyAttack() {
        let result = calculateAttackOutcome(attackPower: enemyInstance.attack, criticalChance: enemyInstance.base.criticalChance, burnChance: enemyInstance.base.burnChance)

        if result.didMiss {
            damageNumbers.append(DamageText(text: "Miss!", color: .gray, isPlayerDamage: true))
            isPlayerTurn = true
            return
        }
        
        var totalDamage = result.damage
        if result.didBurn {
            totalDamage += Int(Double(enemyInstance.attack) * 0.5)
            damageNumbers.append(DamageText(text: "Burn!", color: .orange, isPlayerDamage: true))
        }
        
        playerHealth -= totalDamage
        
        if result.didCrit {
            damageNumbers.append(DamageText(text: "CRITICAL!\n-\(totalDamage)", color: .orange, isPlayerDamage: true))
        } else {
            damageNumbers.append(DamageText(text: "-\(totalDamage)", color: .yellow, isPlayerDamage: true))
        }

        if checkPlayerDefeat() { return }
        
        if result.didStun {
            damageNumbers.append(DamageText(text: "Stunned!", color: .cyan, isPlayerDamage: true))
        } else {
            isPlayerTurn = true
        }
    }
    
    func performOrigamiAttack() {
        isPerformingMultiHit = true
        damageNumbers.append(DamageText(text: "Origami!", color: .cyan, isPlayerDamage: true))
        
        for i in 0..<3 {
            DispatchQueue.main.asyncAfter(deadline: .now() + (0.4 * Double(i))) {
                guard !isBattleOver else { return }
                let damage = Int(Double(enemyInstance.attack) * 0.5) // Each hit does 50% damage
                playerHealth -= damage
                damageNumbers.append(DamageText(text: "-\(damage)", color: .yellow, isPlayerDamage: true))
                if checkPlayerDefeat() { return }
            }
        }
        
        DispatchQueue.main.asyncAfter(deadline: .now() + 1.5) {
            isPerformingMultiHit = false
            isPlayerTurn = true
        }
    }
    
    @discardableResult
    func checkPlayerDefeat() -> Bool {
        if playerHealth <= 0 {
            playerHealth = 0
            isBattleOver = true
            DispatchQueue.main.asyncAfter(deadline: .now() + 1.5) {
                gameStateManager.goBack()
            }
            return true
        }
        return false
    }
    
    @discardableResult
    func checkEnemyDefeat() -> Bool {
        if enemyHealth <= 0 {
            enemyHealth = 0
            isBattleOver = true
            DispatchQueue.main.asyncAfter(deadline: .now() + 1.5) {
                let healthPercentage = Double(playerHealth) / Double(playerChar.health)
                let stars = healthPercentage > 0.75 ? 3 : (healthPercentage > 0.4 ? 2 : 1)
                let moneyGained = gameStateManager.completeLevel(id: level.id, stars: stars)
                gameStateManager.navigateTo(.postLevelVictory(moneyGained: moneyGained, stars: stars))
            }
            return true
        }
        return false
    }
}
